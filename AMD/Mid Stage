import cv2
import numpy as np
import time
from concurrent.futures import ThreadPoolExecutor

# Optimization: Cache Gaussian kernel for reuse
def separable_gaussian_blur(image, kernel_size, sigma):
    k = cv2.getGaussianKernel(kernel_size, sigma)
    return cv2.sepFilter2D(image, -1, k, k)

def create_black_spot_mask(h, w, center_x, center_y, base_radius_x, base_radius_y, max_radius_x, max_radius_y):
    y, x = np.ogrid[:h, :w]
    distance = np.sqrt(((x - center_x) / base_radius_x) ** 2 + ((y - center_y) / base_radius_y) ** 2)
    mask = np.clip(1 - (distance - 1) / ((max_radius_x / base_radius_x) - 1), 0, 1)
    mask[distance < 1] = 1
    return mask

def add_organic_extensions(mask, h, w):
    extension_probability = 0.006
    random_mask = (np.random.rand(h, w) < extension_probability) & (mask > 0.5) & (mask < 1)
    random_indices = np.column_stack(np.where(random_mask))

    for y_ext, x_ext in random_indices:
        blob_radius = np.random.randint(10, 30)
        cv2.circle(mask, (x_ext, y_ext), blob_radius, 1, -1)

    return separable_gaussian_blur(mask.astype(np.float32), 51, 0)

def create_fading_mask(h, w, center_x, center_y, fade_radius):
    y, x = np.ogrid[:h, :w]
    distance_from_center = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
    fade_mask = np.clip((fade_radius - distance_from_center) / fade_radius, 0, 1)
    return separable_gaussian_blur(fade_mask.astype(np.float32), 31, 0)

def apply_distortion(image, center_x, center_y, distortion_radius, amplitude, wavelength):
    h, w = image.shape[:2]
    y_indices, x_indices = np.meshgrid(np.arange(h), np.arange(w), indexing='ij')

    distance_from_center = np.sqrt((x_indices - center_x) ** 2 + (y_indices - center_y) ** 2)
    distortion_mask = distance_from_center <= distortion_radius

    shift_x = (amplitude * np.sin(2 * np.pi * y_indices / wavelength)).astype(int)
    shift_y = (amplitude * np.cos(2 * np.pi * x_indices / wavelength)).astype(int)

    new_x = np.clip(x_indices + shift_x * distortion_mask, 0, w - 1)
    new_y = np.clip(y_indices + shift_y * distortion_mask, 0, h - 1)

    return image[new_y, new_x]

def compute_fading_mask(h, w, center_x, center_y, fade_radius):
    return create_fading_mask(h, w, center_x, center_y, fade_radius)

def compute_black_spot(image, black_spot_mask):
    return image.astype(np.float32) * (1 - black_spot_mask[..., None])

def compute_distortion(faded_image, center_x, center_y, fade_radius, distortion_params):
    distortion_radius = fade_radius + 50
    amplitude, wavelength = distortion_params
    return apply_distortion(cv2.convertScaleAbs(faded_image), center_x, center_y, distortion_radius, amplitude, wavelength)

def simulate_amd_effect(image, black_spot_mask, fading_area_params, distortion_params):
    h, w = image.shape[:2]
    center_x, center_y = w // 2, h // 2

    fade_radius = fading_area_params[0]

    with ThreadPoolExecutor() as executor:
        fading_mask_future = executor.submit(compute_fading_mask, h, w, center_x, center_y, fade_radius)
        black_spot_future = executor.submit(compute_black_spot, image, black_spot_mask)

        fading_mask = fading_mask_future.result()
        fading_mask = cv2.merge([fading_mask] * 3)

        faded_spot = black_spot_future.result()
        faded_image = cv2.addWeighted(faded_spot * fading_mask, 1, image.astype(np.float32) * (1 - fading_mask), 1, 0)

        distorted_image_future = executor.submit(compute_distortion, faded_image, center_x, center_y, fade_radius, distortion_params)
        distorted_image = distorted_image_future.result()

    return distorted_image

# Process real-time video from webcam
cap = cv2.VideoCapture(0)

if not cap.isOpened():
    print("Failed to open webcam")
else:
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)

    black_spot_params = (60, 40, 110, 80)
    fading_area_params = (150,)
    distortion_params = (2, 100)

    ret, frame = cap.read()
    if ret:
        h, w = frame.shape[:2]
        center_x, center_y = w // 2, h // 2

        base_mask = create_black_spot_mask(h, w, center_x, center_y, *black_spot_params)
        black_spot_mask = add_organic_extensions(base_mask, h, w)

    frame_count = 0
    total_processing_time = 0

    start_time_overall = time.time()

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        start_time = time.time()

        processed_frame = simulate_amd_effect(frame, black_spot_mask, fading_area_params, distortion_params)

        processing_time = time.time() - start_time
        total_processing_time += processing_time
        frame_count += 1

        current_time = time.time()
        elapsed_time = current_time - start_time_overall
        fps = frame_count / elapsed_time

        cv2.putText(processed_frame, f"FPS: {fps:.2f}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
        cv2.imshow('Processed Video', processed_frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    overall_fps = frame_count / total_processing_time
    print(f"Overall FPS: {overall_fps:.2f}")

    cap.release()
    cv2.destroyAllWindows()
