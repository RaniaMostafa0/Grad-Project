using UnityEngine;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections.Generic;

public class NuclearCataract : MonoBehaviour
{
    private UIManager ui;
    private Mat processedMat;
    private float updateInterval = 1f / 30f;
    private float lastUpdateTime = 0f;

    void Start()
    {
        ui = GetComponent<UIManager>();
        processedMat = new Mat(ui.webcamMat.rows(), ui.webcamMat.cols(), CvType.CV_8UC4);
    }

    void Update()
    {
        if (ui.webcamTexture == null || !ui.webcamTexture.didUpdateThisFrame) return;

        if (Time.time - lastUpdateTime >= updateInterval)
        {
            Utils.webCamTextureToMat(ui.webcamTexture, ui.webcamMat);
            float intensity = ui.intensitySlider != null ? ui.intensitySlider.value : 0.6f;

            ApplyNuclearCataractEffect(ui.webcamMat, processedMat, intensity);
            Utils.matToTexture2D(processedMat, ui.outputTexture);

            lastUpdateTime = Time.time;
        }
    }

    void ApplyNuclearCataractEffect(Mat input, Mat output, float intensity)
    {
        // 1. Gaussian Blur
        int blurStrength = Mathf.Clamp((int)(intensity * 20), 1, 25);
        if (blurStrength % 2 == 0) blurStrength += 1;

        Mat blurred = new Mat();
        Imgproc.GaussianBlur(input, blurred, new Size(blurStrength, blurStrength), 5);

        // 2. Yellow Tint - Reduce blue channel in RGB
        Mat tinted = new Mat();
        blurred.convertTo(tinted, CvType.CV_32FC3);

        List<Mat> rgbChannels = new List<Mat>();
        Core.split(tinted, rgbChannels);

        if (rgbChannels.Count >= 3)
        {
            // Reduce Blue (channel 2 in RGB)
            Core.multiply(rgbChannels[2], new Scalar(1.0 - 0.5 * intensity), rgbChannels[2]);
        }

        Core.merge(rgbChannels, tinted);
        Core.min(tinted, new Scalar(255, 255, 255), tinted);
        tinted.convertTo(tinted, CvType.CV_8UC3);

        // 3. Adjust Contrast & Brightness
        float contrastFactor = 1.0f - 0.35f * intensity;
        float brightness = 30f * intensity;

        Mat contrastAdjusted = new Mat();
        tinted.convertTo(contrastAdjusted, -1, contrastFactor, brightness);

        // 4. Convert to RGBA and set alpha channel to opaque
        Mat rgba = new Mat();
        Imgproc.cvtColor(contrastAdjusted, rgba, Imgproc.COLOR_RGB2RGBA);

        List<Mat> rgbaChannels = new List<Mat>();
        Core.split(rgba, rgbaChannels);
        if (rgbaChannels.Count == 4)
        {
            rgbaChannels[3].setTo(new Scalar(255)); // full opacity
            Core.merge(rgbaChannels, rgba);
        }

        rgba.copyTo(output);

        // Clean up
        blurred.Dispose();
        tinted.Dispose();
        contrastAdjusted.Dispose();
        foreach (var ch in rgbChannels) ch.Dispose();
        foreach (var ch in rgbaChannels) ch.Dispose();
        rgba.Dispose();
    }

    void OnDestroy()
    {
        if (processedMat != null) processedMat.Dispose();
    }
}
