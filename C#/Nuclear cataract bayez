using UnityEngine;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections.Generic;

public class NuclearCataract : MonoBehaviour
{
    private UIManager ui;
    private Mat processedMat;
    private float updateInterval = 1f / 30f;
    private float lastUpdateTime = 0f;

    void Start()
    {
        ui = GetComponent<UIManager>();
        processedMat = new Mat(ui.webcamMat.rows(), ui.webcamMat.cols(), CvType.CV_8UC4);
    }

    void Update()
    {
        if (ui.webcamTexture == null || !ui.webcamTexture.didUpdateThisFrame) return;

        if (Time.time - lastUpdateTime >= updateInterval)
        {
            Utils.webCamTextureToMat(ui.webcamTexture, ui.webcamMat);
            float intensity = ui.intensitySlider != null ? ui.intensitySlider.value : 0.6f;

            ApplyNuclearCataractEffect(ui.webcamMat, processedMat, intensity);
            Utils.matToTexture2D(processedMat, ui.outputTexture);

            lastUpdateTime = Time.time;
        }
    }

    void ApplyNuclearCataractEffect(Mat input, Mat output, float intensity)
    {
        // 1. Apply Gaussian Blur
        int blurStrength = Mathf.Clamp((int)(intensity * 20), 1, 25);
        if (blurStrength % 2 == 0) blurStrength += 1;

        Mat blurred = new Mat();
        Imgproc.GaussianBlur(input, blurred, new Size(blurStrength, blurStrength), 5);

        // 2. Apply Yellow Tint (simulate reduction of blue channel)
        Mat tinted = new Mat();
        blurred.convertTo(tinted, CvType.CV_32FC3);

        List<Mat> channels = new List<Mat>();
        Core.split(tinted, channels);

        if (channels.Count >= 3)
        {
            // Reduce Blue channel based on intensity
            Core.multiply(channels[0], new Scalar(1.0 - 0.5 * intensity), channels[0]);
        }

        Core.merge(channels, tinted);
        Core.min(tinted, new Scalar(255, 255, 255), tinted);
        tinted.convertTo(tinted, CvType.CV_8UC3);

        // 3. Contrast and Brightness Adjustment
        float contrastFactor = 1.0f - 0.35f * intensity;
        float brightness = 30f * intensity;
        Mat finalResult = new Mat();
        tinted.convertTo(finalResult, -1, contrastFactor, brightness);

        // 4. Convert to RGBA
        Mat rgba = new Mat();
        Imgproc.cvtColor(finalResult, rgba, Imgproc.COLOR_RGB2RGBA);

        // Set full opacity
        List<Mat> rgbaChannels = new List<Mat>();
        Core.split(rgba, rgbaChannels);
        if (rgbaChannels.Count == 4)
        {
            rgbaChannels[3].setTo(new Scalar(255));
            Core.merge(rgbaChannels, rgba);
        }

        rgba.copyTo(output);

        // Clean up
        blurred.Dispose();
        tinted.Dispose();
        finalResult.Dispose();
        foreach (var ch in channels) ch.Dispose();
        foreach (var ch in rgbaChannels) ch.Dispose();
        rgba.Dispose();
    }


    void OnDestroy()
    {
        if (processedMat != null) processedMat.Dispose();
    }
}
