import cv2
import numpy as np
from scipy.interpolate import splprep, splev
import time
import pygame
import sys

# ================== Tunnel Vision Functions ==================

def separable_gaussian_blur(image, kernel_size, sigma):
    """Apply Gaussian blur more efficiently."""
    return cv2.GaussianBlur(image, (kernel_size, kernel_size), sigma)

def simulate_night_blindness(image):
    """Simulate moderate night blindness for the middle stage."""
    darkened_image = image * 0.4
    darkened_image = np.clip(darkened_image, 0, 255)
    blurred_image = separable_gaussian_blur(darkened_image, 25, 8)
    return blurred_image.astype(np.uint8)

def detect_light_condition(frame):
    """Detect the average brightness of the frame using the green channel."""
    return np.mean(frame[:, :, 1])

def create_static_irregular_mask(shape, radius_scale=0.9, noise_strength=0.7, edge_fade_size=199, seed=42):
    """Create a static irregular mask for tunnel vision."""
    np.random.seed(seed)  # Ensure mask is static across frames
    rows, cols = shape
    center_x, center_y = cols // 2, rows // 2
    base_radius = int(min(center_x, center_y) * radius_scale)

    y, x = np.ogrid[:rows, :cols]
    angle = np.arctan2(y - center_y, x - center_x)
    distance_from_center = np.sqrt((x - center_x)**2 + (y - center_y)**2)

    # Generate irregular radii
    random_radii = base_radius * (1 + noise_strength * (np.random.rand(360) - 0.5))
    radius_map = np.interp((np.degrees(angle) + 360) % 360, np.arange(360), random_radii)

    irregular_mask = (distance_from_center < radius_map).astype(np.float32)
    irregular_mask = cv2.GaussianBlur(irregular_mask, (edge_fade_size, edge_fade_size), 0)

    return irregular_mask

def apply_static_tunnel_vision(image_rgb, static_mask):
    """Apply a precomputed static irregular mask to the image."""
    vision_image = image_rgb.astype(np.float32)
    vision_image *= static_mask[:, :, np.newaxis]  # Vectorized multiplication
    vision_image = np.clip(vision_image, 0, 255)
    return vision_image.astype(np.uint8)

# ================== Irregular Shapes Functions ==================

def create_irregular_shape(center, width, height, num_points=40, irregularity=2.0, spline_degree=3, smoothing_factor=50, seed=None):
    """
    Generates an irregular, non-circular shape with fixed width and height using deterministic points and spline interpolation.
    """
    if seed is not None:
        rng = np.random.RandomState(seed)
    else:
        rng = np.random

    # Generate angles and random perturbations
    angles = np.linspace(0, 2 * np.pi, num_points, endpoint=False)
    angles += rng.uniform(-irregularity, irregularity, size=num_points)

    radii_x = width / 2
    radii_y = height / 2

    # Calculate (x, y) points
    x = center[0] + radii_x * np.cos(angles) * rng.uniform(0.8, 1.2, size=num_points)
    y = center[1] + radii_y * np.sin(angles) * rng.uniform(0.8, 1.2, size=num_points)
    points = np.vstack((x, y)).T

    # Sort points by angle to ensure a coherent polygon
    centroid = np.mean(points, axis=0)
    angles_sorted = np.arctan2(points[:,1] - centroid[1], points[:,0] - centroid[0])
    sorted_indices = np.argsort(angles_sorted)
    points = points[sorted_indices]

    # Spline interpolation
    try:
        tck, _ = splprep([points[:,0], points[:,1]], s=smoothing_factor, per=True, k=spline_degree)
        u_fine = np.linspace(0, 1, 400)  # More points for finer curves
        x_fine, y_fine = splev(u_fine, tck)
        smooth_points = np.vstack((x_fine, y_fine)).T.astype(np.int32)
    except Exception as e:
        print(f"Error in spline interpolation: {e}")
        smooth_points = points.astype(np.int32)

    return smooth_points

def smoothing_factor_adjust(irregularity):
    """
    Adjust the smoothing factor based on the level of irregularity.
    """
    return max(10, 75 - (irregularity * 5))

def create_irregular_shapes_mask(shape, shape_color=(0, 0, 0), num_shapes=3, 
                                width=400, height=100, placement_radius=170, irregularity=2.0):
    """
    Creates a static mask with exactly three irregular, centrally located shapes.
    """
    height_img, width_img = shape
    image_center = (width_img // 2, height_img // 2)

    # Fixed angles for deterministic placement
    angles_deg = [0, 120, 240]
    angles_rad = [np.deg2rad(angle) for angle in angles_deg]

    mask = np.zeros((height_img, width_img), dtype=np.uint8)

    for i, angle in enumerate(angles_rad):
        center_x = int(image_center[0] + placement_radius * np.cos(angle))
        center_y = int(image_center[1] + placement_radius * np.sin(angle))
        new_center = (center_x, center_y)

        seed = i  # Deterministic irregularity

        shape_points = create_irregular_shape(
            center=new_center,
            width=width,
            height=height,
            num_points=30,
            irregularity=irregularity,
            spline_degree=3,
            smoothing_factor=smoothing_factor_adjust(irregularity),
            seed=seed
        )

        # Draw the shape on the mask
        cv2.fillPoly(mask, [shape_points], 255)

    # Smooth mask edges
    mask = cv2.GaussianBlur(mask, (51, 51), 0)
    mask = cv2.medianBlur(mask, 15)

    return mask

def apply_irregular_shapes(tunnel_vision_image, shapes_mask, opacity=0.8):
    """Blend the precomputed irregular shapes mask with the tunnel vision image."""
    tunnel_float = tunnel_vision_image.astype(np.float32)
    shapes_float = shapes_mask.astype(np.float32) / 255.0
    
    # Expand dims to match (height, width, 3)
    shapes_float = shapes_float[:, :, np.newaxis]

    # Create an overlay with the desired shape color (black)
    overlay = np.zeros_like(tunnel_float)

    # Blend overlay with the original image using the mask and opacity
    blended = tunnel_float * (1 - shapes_float * opacity) + overlay * (shapes_float * opacity)
    blended = np.clip(blended, 0, 255).astype(np.uint8)

    return blended

# ================== Image Processing ==================

def resize_image(image, desired_width=1280, desired_height=720):
    """
    Resizes the image to the desired dimensions.
    """
    return cv2.resize(image, (desired_width, desired_height), interpolation=cv2.INTER_AREA)

# ================== Pygame Display and FPS Calculation ==================

def main():
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("Error: Could not open webcam.")
        return

    desired_width = 1280
    desired_height = 720
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, desired_width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, desired_height)

    time.sleep(2.0)

    ret, frame = cap.read()
    if not ret:
        print("Error: Could not read frame from webcam.")
        cap.release()
        return

    frame = resize_image(frame, desired_width, desired_height)

    # Precompute tunnel vision mask
    static_mask = create_static_irregular_mask(
        frame.shape[:2],
        radius_scale=0.9,
        noise_strength=0.7,
        edge_fade_size=199,
        seed=42
    )

    # Precompute irregular shapes mask
    shapes_mask = create_irregular_shapes_mask(
        frame.shape[:2],
        shape_color=(0, 0, 0),
        num_shapes=3,
        width=350,
        height=130,
        placement_radius=170,
        irregularity=1.5
    )

    static_mask_float = static_mask.astype(np.float32)
    shapes_mask_float = shapes_mask.astype(np.float32) / 255.0  # Not used directly in main loop here

    pygame.init()
    pygame.display.set_caption("Real-Time Tunnel Vision with Black Shapes")
    screen = pygame.display.set_mode((desired_width, desired_height), pygame.FULLSCREEN)
    pygame.font.init()
    font = pygame.font.SysFont("Arial", 24)
    clock = pygame.time.Clock()

    fps_display_interval = 1
    fps_timer = time.time()
    fps_count = 0
    fps = 0

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False

        ret, frame = cap.read()
        if not ret:
            print("Error: Could not read frame from webcam.")
            break

        frame = resize_image(frame, desired_width, desired_height)
        
        # ================== Mirror the Frame Horizontally ==================
        mirrored_frame = cv2.flip(frame, 1)  # Horizontal flip to fix mirrored view

        start_time = time.time()

        # Optionally simulate night blindness
        # mirrored_frame = simulate_night_blindness(mirrored_frame)

        # Apply tunnel vision
        tunnel_vision_image = apply_static_tunnel_vision(mirrored_frame, static_mask_float)

        # Apply irregular black shapes
        processed_image = apply_irregular_shapes(tunnel_vision_image, shapes_mask, opacity=0.8)

        end_time = time.time()
        elapsed_time = end_time - start_time

        fps_count += 1
        if (end_time - fps_timer) > fps_display_interval:
            fps = fps_count / (end_time - fps_timer)
            fps_timer = end_time
            fps_count = 0

        processed_image_rgb = cv2.cvtColor(processed_image, cv2.COLOR_BGR2RGB)
        processed_image_rgb = np.rot90(processed_image_rgb)
        frame_surface = pygame.surfarray.make_surface(processed_image_rgb)

        screen.blit(frame_surface, (0, 0))

        fps_text = font.render(f"FPS: {fps:.2f}", True, (255, 255, 255))
        screen.blit(fps_text, (10, desired_height - 30))

        pygame.display.flip()
        clock.tick(60)

    cap.release()
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
