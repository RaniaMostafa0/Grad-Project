using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class AMDEffect : MonoBehaviour
{
    [Header("AMD Settings")]
    [SerializeField] private int maxKernelSize = 51;
    [SerializeField] private float spotStartThreshold = 0.3f;

    private RawImage display;
    private Slider intensitySlider;
    private WebCamTexture cam;
    private Texture2D tex;

    private Mat matInput;
    private Mat matProcessed;
    private Mat matBlurred;
    private Mat blurMask;
    private Mat spotCoreMask;
    private Mat spotOuterMask;
    private Mat noiseMap;

    private bool initialized = false;

    public void Initialize(RawImage target, Slider slider, WebCamTexture sharedCam)
    {
        display = target;
        intensitySlider = slider;
        cam = sharedCam;

        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitForWebCamInit());
    }

    IEnumerator WaitForWebCamInit()
    {
        while (cam.width <= 16)
            yield return null;

        int width = cam.width;
        int height = cam.height;

        tex = new Texture2D(width, height, TextureFormat.RGBA32, false);
        display.texture = tex;

        matInput = new Mat(height, width, CvType.CV_8UC4);
        matProcessed = new Mat(height, width, CvType.CV_8UC4);
        matBlurred = new Mat(height, width, CvType.CV_8UC4);
        blurMask = new Mat(height, width, CvType.CV_32F);
        spotCoreMask = new Mat(height, width, CvType.CV_32F);
        spotOuterMask = new Mat(height, width, CvType.CV_32F);
        noiseMap = generateStaticNoiseMap(height, width);

        initialized = true;
    }

    void Update()
    {
        if (!initialized || cam == null || !cam.didUpdateThisFrame)
            return;

        Utils.webCamTextureToMat(cam, matInput);

        float t = intensitySlider != null ? intensitySlider.value : 0f;
        float progression = Mathf.Clamp01(t);

        GenerateBlurMask(progression);
        GenerateSpotMask(progression);
        ApplyEffects(progression);

        Utils.fastMatToTexture2D(matProcessed, tex);
    }

    private void GenerateBlurMask(float progression)
    {
        int width = blurMask.cols();
        int height = blurMask.rows();
        float cx = width / 2f;
        float cy = height / 2f;

        blurMask.setTo(new Scalar(1f));

        float maxRadius = Mathf.Lerp(50f, 200f, progression); // Starts small, grows with progression
        float fadeWidth = 50f;
        float noiseScale = 0.05f;

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                float dx = x - cx;
                float dy = y - cy;
                float dist = Mathf.Sqrt(dx * dx + dy * dy);

                float perlin = Mathf.PerlinNoise(x * noiseScale, y * noiseScale) * 10f;
                float rBlur = maxRadius + perlin;

                float maskVal = 1f;
                if (dist < rBlur - fadeWidth / 2f)
                    maskVal = 0f;
                else if (dist < rBlur + fadeWidth / 2f)
                    maskVal = (dist - (rBlur - fadeWidth / 2f)) / fadeWidth;

                blurMask.put(y, x, Mathf.Clamp01(maskVal));
            }
        }

        int dynamicKernelSize = Mathf.Max(3, (int)(progression * maxKernelSize)); // Dynamic blur strength
        if (dynamicKernelSize % 2 == 0) dynamicKernelSize++; // Make sure it's odd
        Imgproc.GaussianBlur(blurMask, blurMask, new Size(dynamicKernelSize, dynamicKernelSize), 0);
    }


    private void GenerateSpotMask(float progression)
    {
        int width = matInput.cols();
        int height = matInput.rows();
        float cx = width / 2f;
        float cy = height / 2f;

        spotCoreMask.setTo(new Scalar(1f));
        spotOuterMask.setTo(new Scalar(1f));

        if (progression < spotStartThreshold)
            return;

        float normalizedProgress = (progression - spotStartThreshold) / (1f - spotStartThreshold);

        float minRadius = 10f;
        float maxOuterRadius = 150f;
        float maxCoreRadius = 140f; // A little smaller so it "catches" the outer at the end

        // Ease-out for smoother progression
        float easedProgress = Mathf.Sqrt(normalizedProgress);

        // Faded outer circle grows immediately
        float outerRadius = Mathf.Lerp(minRadius, maxOuterRadius, easedProgress);

        // Core black spot grows later
        float coreStartDelay = 0.4f; // Start growing after 40% progression
        float coreProgress = Mathf.Clamp01((easedProgress - coreStartDelay) / (1f - coreStartDelay));
        float coreRadius = Mathf.Lerp(minRadius * 0.5f, maxCoreRadius, coreProgress);

        float fadeWidth = 50f;
        float noiseScale = 0.05f;

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                float dx = x - cx;
                float dy = y - cy;
                float dist = Mathf.Sqrt(dx * dx + dy * dy);

                float perlin = Mathf.PerlinNoise(x * noiseScale, y * noiseScale) * 10f;

                float rCore = coreRadius + perlin;
                float rOuter = outerRadius + perlin;

                // Core black spot
                float coreValue = 1f;
                if (dist < rCore - fadeWidth / 2f)
                    coreValue = 0f;
                else if (dist < rCore + fadeWidth / 2f)
                    coreValue = (dist - (rCore - fadeWidth / 2f)) / fadeWidth;
                spotCoreMask.put(y, x, Mathf.Clamp01(coreValue));

                // Outer faded circle
                float outerValue = 1f;
                if (dist < rOuter - fadeWidth / 2f)
                    outerValue = 0.3f;
                else if (dist < rOuter + fadeWidth / 2f)
                    outerValue = Mathf.Lerp(0.3f, 1f, (dist - (rOuter - fadeWidth / 2f)) / fadeWidth);
                spotOuterMask.put(y, x, Mathf.Clamp01(outerValue));
            }
        }

        int dynamicKernelSize = Mathf.Max(3, (int)(easedProgress * maxKernelSize));
        if (dynamicKernelSize % 2 == 0) dynamicKernelSize++;
        Imgproc.GaussianBlur(spotCoreMask, spotCoreMask, new Size(dynamicKernelSize, dynamicKernelSize), 0);
        Imgproc.GaussianBlur(spotOuterMask, spotOuterMask, new Size(dynamicKernelSize, dynamicKernelSize), 0);
    }




    private void ApplyEffects(float progression)
    {
        matProcessed.setTo(new Scalar(0));

        int blurKernelSize = Mathf.Clamp((

int)(progression * maxKernelSize), 1, maxKernelSize);
        if (blurKernelSize % 2 == 0) blurKernelSize++;
        Imgproc.GaussianBlur(matInput, matBlurred, new Size(blurKernelSize, blurKernelSize), 0);

        int rows = matInput.rows();
        int cols = matInput.cols();

        for (int y = 0; y < rows; y++)
        {
            for (int x = 0; x < cols; x++)
            {
                double[] original = matInput.get(y, x);
                double[] blurred = matBlurred.get(y, x);

                float blurWeight = (float)blurMask.get(y, x)[0];
                float coreWeight = (float)spotCoreMask.get(y, x)[0];
                float outerWeight = (float)spotOuterMask.get(y, x)[0];

                float r = Mathf.Lerp(0f, Mathf.Lerp((float)blurred[0], (float)original[0], blurWeight), coreWeight * outerWeight);
                float g = Mathf.Lerp(0f, Mathf.Lerp((float)blurred[1], (float)original[1], blurWeight), coreWeight * outerWeight);
                float b = Mathf.Lerp(0f, Mathf.Lerp((float)blurred[2], (float)original[2], blurWeight), coreWeight * outerWeight);

                matProcessed.put(y, x, new double[] { r, g, b, original[3] });
            }
        }
    }

    private Mat generateStaticNoiseMap(int height, int width, int blurSize = 51)
    {
        Mat noise = new Mat(height, width, CvType.CV_32F);
        Core.randn(noise, 0.0, 1.0);
        Imgproc.GaussianBlur(noise, noise, new Size(blurSize, blurSize), 0);

        Core.MinMaxLocResult mm = Core.minMaxLoc(noise);
        Core.subtract(noise, new Scalar(mm.minVal), noise);
        Core.divide(noise, new Scalar(mm.maxVal - mm.minVal), noise);
        Core.multiply(noise, new Scalar(2.0), noise);
        Core.subtract(noise, new Scalar(1.0), noise);

        return noise;
    }

    void OnDisable() { /* cam?.Stop(); */ }

    void OnDestroy()
    {
        cam?.Stop();
        matInput?.Dispose();
        matProcessed?.Dispose();
        matBlurred?.Dispose();
        blurMask?.Dispose();
        spotCoreMask?.Dispose();
        spotOuterMask?.Dispose();
        noiseMap?.Dispose();
    }
}
