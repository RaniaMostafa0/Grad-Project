using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class AMDEffect : MonoBehaviour
{
    /* ───── Inspector Parameters ───── */
    [Header("Blur & Black-Spot")]
    [SerializeField] private int   maxKernelSize       = 51;
    [SerializeField] private float spotStartThreshold = 0.3f;
    [SerializeField] private float maxOuterRadius     = 300f;
    [SerializeField] private float maxCoreRadius      = 280f;

    [Header("Wavy Distortion Ring")]
    [Tooltip("Maximum pixel offset at full progression")]
    [SerializeField] private float maxDistortionPixels = 10f;

    [Tooltip("Full sine period in pixels")]
    [SerializeField] private float distortionPeriod = 120f;

    [Tooltip("Pixels added to the core radius before waves begin")]
    [SerializeField] private float ringExpansion = 15f;

    [Tooltip("Thickness of the wavy band (pixels)")]
    [SerializeField] private float ringWidth = 35f;

    /* ───── Runtime refs ───── */
    private RawImage      display;
    private Slider        slider;
    private WebCamTexture cam;
    private Texture2D     tex;

    /* ───── Video buffers ───── */
    private Mat src8, blur8;
    private Mat src32, blur32, warped32, dst32, dst8;

    /* ───── Masks & helpers ───── */
    private Mat blurMask, spotCoreMask, spotOuterMask;
    private Mat distortionMask;                 // NEW
    private Mat edgeMask, noiseMap, radiusMap, irregular, tmp32, ones32;
    private Mat blur4, invBlur4, coreOuter4;

    /* ───── Distortion maps ───── */
    private Mat baseMapX, baseMapY;         // identity maps
    private Mat sinX, sinY;                 // pre-baked sine matrices
    private Mat mapX, mapY;                 // per-frame remap

    /* ───── State ───── */
    private bool  ready   = false;
    private float lastVal = -1f, progress = 0f;

    /* ───────── initialise ───────── */
    public void Initialize(RawImage tgt, Slider s, WebCamTexture sharedCam)
    {
        display = tgt; slider = s; cam = sharedCam;
        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitCam());
    }

    IEnumerator WaitCam()
    {
        while (cam.width <= 16) yield return null;
        int w = cam.width, h = cam.height;

        /* GPU tex */
        tex            = new Texture2D(w, h, TextureFormat.RGBA32, false);
        display.texture = tex;

        /* video frames */
        src8   = new Mat(h, w, CvType.CV_8UC4);
        blur8  = new Mat(h, w, CvType.CV_8UC4);
        src32  = new Mat(h, w, CvType.CV_32FC4);
        blur32 = new Mat(h, w, CvType.CV_32FC4);
        warped32 = new Mat(h, w, CvType.CV_32FC4);
        dst32  = new Mat(h, w, CvType.CV_32FC4);
        dst8   = new Mat(h, w, CvType.CV_8UC4);

        /* masks */
        blurMask       = new Mat(h, w, CvType.CV_32F);
        spotCoreMask   = new Mat(h, w, CvType.CV_32F);
        spotOuterMask  = new Mat(h, w, CvType.CV_32F);
        distortionMask = new Mat(h, w, CvType.CV_32F);   // NEW
        edgeMask       = new Mat(h, w, CvType.CV_32F);

        /* helpers */
        noiseMap  = GenNoise(h, w);
        radiusMap = GenRadius(h, w);
        irregular = new Mat(h, w, CvType.CV_32F);
        tmp32     = new Mat(h, w, CvType.CV_32F);
        ones32    = Mat.ones(h, w, CvType.CV_32F);

        blur4      = new Mat(h, w, CvType.CV_32FC4);
        invBlur4   = new Mat(h, w, CvType.CV_32FC4);
        coreOuter4 = new Mat(h, w, CvType.CV_32FC4);

        /* distortion maps ------------------------------------- */
        baseMapX = new Mat(h, w, CvType.CV_32F);
        baseMapY = new Mat(h, w, CvType.CV_32F);
        sinX     = new Mat(h, w, CvType.CV_32F);
        sinY     = new Mat(h, w, CvType.CV_32F);
        mapX     = new Mat(h, w, CvType.CV_32F);
        mapY     = new Mat(h, w, CvType.CV_32F);

        for (int y = 0; y < h; y++)
        {
            float sy = Mathf.Sin(2f * Mathf.PI * y / distortionPeriod);
            for (int x = 0; x < w; x++)
            {
                baseMapX.put(y, x, x);
                baseMapY.put(y, x, y);

                float sx = Mathf.Sin(2f * Mathf.PI * x / distortionPeriod);
                sinX.put(y, x, sy);      // X offset depends on Y
                sinY.put(y, x, sx);      // Y offset depends on X
            }
        }

        ready = true;
    }

    /* ───────── update ───────── */
    void Update()
    {
        if (!ready || !cam.didUpdateThisFrame) return;
        Utils.webCamTextureToMat(cam, src8);

        float val = slider ? slider.value : 0f;
        if (!Mathf.Approximately(val, lastVal))
        {
            progress = Mathf.Clamp01(val);
            BuildMasksAndWarpMaps(progress);
            lastVal = val;
        }

        /* dynamic blur strength */
        int k = Mathf.Clamp((int)(progress * maxKernelSize), 1, maxKernelSize);
        if ((k & 1) == 0) k++;
        Imgproc.GaussianBlur(src8, blur8, new Size(k, k), 0);

        /* float convert */
        src8.convertTo(src32, CvType.CV_32FC4);
        blur8.convertTo(blur32, CvType.CV_32FC4);

        /* ----------  apply wavy remap ---------- */
        Imgproc.remap(src32, warped32, mapX, mapY, Imgproc.INTER_LINEAR);

        /* original / blur blend */
        Core.multiply(warped32, blur4, dst32);
        Core.multiply(blur32,  invBlur4, tmp32);
        Core.add(dst32, tmp32, dst32);

        /* black spot */
        Core.multiply(dst32, coreOuter4, dst32);

        /* upload */
        dst32.convertTo(dst8, CvType.CV_8UC4);
        Utils.fastMatToTexture2D(dst8, tex);
    }

    /* ───────── Build masks + warp maps  ───────── */
    void BuildMasksAndWarpMaps(float p)
    {
        BuildBlurMask(p);
        BuildSpotMasks(p);                     // builds distortionMask too

        /* Expand blurMask to 4-channel */
        Imgproc.cvtColor(blurMask, blur4, Imgproc.COLOR_GRAY2RGBA);
        Core.subtract(ones32, blurMask, tmp32);
        Imgproc.cvtColor(tmp32, invBlur4, Imgproc.COLOR_GRAY2RGBA);

        Core.multiply(spotCoreMask, spotOuterMask, edgeMask);
        Imgproc.cvtColor(edgeMask, coreOuter4, Imgproc.COLOR_GRAY2RGBA);

        /* --------- distortion remap --------- */
        float amp = maxDistortionPixels * p;
        Core.multiply(sinX, new Scalar(amp), mapX);   // mapX = amp·sinX
        Core.multiply(sinY, new Scalar(amp), mapY);   // mapY = amp·sinY
        Core.multiply(mapX, distortionMask, mapX);    // only in ring
        Core.multiply(mapY, distortionMask, mapY);

        Core.add(baseMapX, mapX, mapX);               // add to identity
        Core.add(baseMapY, mapY, mapY);
    }

    /* ───────── individual mask builders ───────── */
    void BuildBlurMask(float p)
    {
        float baseR = Mathf.Lerp(50f, 200f, p);
        float fade  = 50f;  float amp = 10f;

        Core.multiply(noiseMap, new Scalar(amp), irregular);
        Core.add(irregular, new Scalar(baseR), irregular);

        Core.subtract(radiusMap, irregular, blurMask);
        Core.add(blurMask, new Scalar(fade * .5f), blurMask);
        Core.divide(blurMask, new Scalar(fade), blurMask);
        Core.min(blurMask, new Scalar(1f), blurMask); Core.max(blurMask, new Scalar(0f), blurMask);

        int k = Mathf.Max(3, (int)(p * maxKernelSize)); if ((k & 1) == 0) k++;
        Imgproc.GaussianBlur(blurMask, blurMask, new Size(k, k), 0);
    }

    void BuildSpotMasks(float p)
    {
        spotCoreMask.setTo(new Scalar(1f));
        spotOuterMask.setTo(new Scalar(1f));
        distortionMask.setTo(new Scalar(0f));           // reset

        if (p < spotStartThreshold) return;

        /* --- radii --- */
        float t  = (p - spotStartThreshold) / (1f - spotStartThreshold);
        float e  = Mathf.Sqrt(t);
        float oR = Mathf.Lerp(10f, maxOuterRadius, e);

        float d  = 0.4f;
        float cp = Mathf.Clamp01((e - d) / (1f - d));
        float cR = Mathf.Lerp(5f, maxCoreRadius, cp);

        float fade = 50f; float amp = 10f;

        /* -------- outer halo -------- */
        Core.multiply(noiseMap, new Scalar(amp), irregular);
        Core.add(irregular, new Scalar(oR), irregular);
        Core.subtract(radiusMap, irregular, spotOuterMask);
        Core.add(spotOuterMask, new Scalar(fade * .5f), spotOuterMask);
        Core.divide(spotOuterMask, new Scalar(fade), spotOuterMask);
        Core.min(spotOuterMask, new Scalar(1f), spotOuterMask);
        Core.max(spotOuterMask, new Scalar(0.3f), spotOuterMask);

        /* -------- dark core -------- */
        Core.add(irregular, new Scalar(cR - oR), irregular);
        Core.subtract(radiusMap, irregular, spotCoreMask);
        Core.add(spotCoreMask, new Scalar(fade * .5f), spotCoreMask);
        Core.divide(spotCoreMask, new Scalar(fade), spotCoreMask);
        Core.min(spotCoreMask, new Scalar(1f), spotCoreMask);
        Core.max(spotCoreMask, new Scalar(0f), spotCoreMask);

        /* -------- wavy ring mask (NEW) -------- */
        float inner = cR + ringExpansion;
        float outer = inner + ringWidth;                // outer radius of ring

        // tmp32 = radiusMap - inner
        Core.subtract(radiusMap, new Scalar(inner), tmp32);
        Core.max(tmp32, new Scalar(0f), tmp32);         // clamp negatives

        // irregular = constant matrix (outer - inner)
        Core.multiply(ones32, new Scalar(outer - inner), irregular);

        // tmp32 = (outer-inner) - tmp32
        Core.subtract(irregular, tmp32, tmp32);

        // distortionMask = clamp01(tmp32 / (outer - inner))
        Core.divide(tmp32, new Scalar(outer - inner), distortionMask);
        Core.min(distortionMask, new Scalar(1f), distortionMask);
        Core.max(distortionMask, new Scalar(0f), distortionMask);

        /* -------- smoothing -------- */
        int k = Mathf.Max(3, (int)(e * maxKernelSize)); if ((k & 1) == 0) k++;
        Imgproc.GaussianBlur(spotOuterMask,  spotOuterMask,  new Size(k, k), 0);
        Imgproc.GaussianBlur(spotCoreMask,   spotCoreMask,   new Size(k, k), 0);
        Imgproc.GaussianBlur(distortionMask, distortionMask, new Size(k, k), 0);
    }

    /* ───────── helpers ───────── */
    Mat GenRadius(int h, int w)
    {
        Mat r = new Mat(h, w, CvType.CV_32F);
        float cx = w * .5f, cy = h * .5f;
        for (int y = 0; y < h; y++)
        {
            float dy2 = (y - cy) * (y - cy);
            for (int x = 0; x < w; x++)
                r.put(y, x, Mathf.Sqrt((x - cx) * (x - cx) + dy2));
        }
        return r;
    }
    Mat GenNoise(int h, int w, int blur = 51)
    {
        Mat n = new Mat(h, w, CvType.CV_32F);
        Core.randn(n, 0, 1); Imgproc.GaussianBlur(n, n, new Size(blur, blur), 0);
        Core.MinMaxLocResult mm = Core.minMaxLoc(n);
        Core.subtract(n, new Scalar(mm.minVal), n);
        Core.divide(n, new Scalar(mm.maxVal - mm.minVal), n);
        Core.multiply(n, new Scalar(2), n); Core.subtract(n, new Scalar(1), n);
        return n;
    }

    /* ───────── cleanup ───────── */
    void OnDestroy()
    {
        cam?.Stop();
        foreach (Mat m in new[]
        { src8, blur8, src32, blur32, warped32, dst32, dst8,
          blurMask, spotCoreMask, spotOuterMask, distortionMask,
          edgeMask, noiseMap, radiusMap, irregular, tmp32, ones32,
          blur4, invBlur4, coreOuter4,
          baseMapX, baseMapY, sinX, sinY, mapX, mapY })
            m?.Dispose();
    }
}
