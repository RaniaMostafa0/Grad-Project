using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class AMDEffect : MonoBehaviour
{
    /* ───── Inspector Parameters ───── */
    [Header("Blur & Black-Spot")]
    [SerializeField] private int   maxKernelSize       = 51;
    [SerializeField] private float spotStartThreshold = 0.3f;
    [SerializeField] private float maxOuterRadius     = 300f;
    [SerializeField] private float maxCoreRadius      = 280f;

    [Header("Organic Extensions")]
    [Tooltip("Largest outward push (pixels) given to the core outline at full progression")]
    [SerializeField] private float extensionMaxPixels = 40f;

    [Header("Wavy Distortion Ring")]
    [SerializeField] private float maxDistortionPixels = 10f;   // max sine offset
    [SerializeField] private float distortionPeriod    = 120f;  // sine wavelength
    [SerializeField] private float ringExpansion       = 15f;   // ring starts this far past core
    [SerializeField] private float ringWidth           = 35f;   // ring thickness

    /* ───── Runtime refs ───── */
    private RawImage      display;
    private Slider        slider;
    private WebCamTexture cam;
    private Texture2D     tex;

    /* ───── Video buffers ───── */
    private Mat src8, blur8;
    private Mat src32, blur32, warped32, dst32, dst8;

    /* ───── Masks & helpers ───── */
    private Mat blurMask, spotCoreMask, spotOuterMask;
    private Mat distortionMask;
    private Mat edgeMask, noiseMap, radiusMap, irregular, tmp32, ones32;
    private Mat blur4, invBlur4, coreOuter4;

    /* ───── Distortion maps ───── */
    private Mat baseMapX, baseMapY, sinX, sinY, mapX, mapY;

    /* ───── State ───── */
    private bool  ready   = false;
    private float lastVal = -1f, progress = 0f;

    /* ───────── initialise ───────── */
    public void Initialize(RawImage tgt, Slider s, WebCamTexture sharedCam)
    {
        display = tgt; slider = s; cam = sharedCam;
        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitCam());
    }

    IEnumerator WaitCam()
    {
        while (cam.width <= 16) yield return null;
        int w = cam.width, h = cam.height;

        /* GPU tex */
        tex            = new Texture2D(w, h, TextureFormat.RGBA32, false);
        display.texture = tex;

        /* video frames */
        src8  = new Mat(h, w, CvType.CV_8UC4);
        blur8 = new Mat(h, w, CvType.CV_8UC4);
        src32 = new Mat(h, w, CvType.CV_32FC4);
        blur32= new Mat(h, w, CvType.CV_32FC4);
        warped32 = new Mat(h, w, CvType.CV_32FC4);
        dst32 = new Mat(h, w, CvType.CV_32FC4);
        dst8  = new Mat(h, w, CvType.CV_8UC4);

        /* masks */
        blurMask       = new Mat(h, w, CvType.CV_32F);
        spotCoreMask   = new Mat(h, w, CvType.CV_32F);
        spotOuterMask  = new Mat(h, w, CvType.CV_32F);
        distortionMask = new Mat(h, w, CvType.CV_32F);
        edgeMask       = new Mat(h, w, CvType.CV_32F);

        /* helpers */
        noiseMap  = GenNoise(h, w, 111);      // smooth noise −1..+1
        radiusMap = GenRadius(h, w);
        irregular = new Mat(h, w, CvType.CV_32F);
        tmp32     = new Mat(h, w, CvType.CV_32F);
        ones32    = Mat.ones(h, w, CvType.CV_32F);

        blur4      = new Mat(h, w, CvType.CV_32FC4);
        invBlur4   = new Mat(h, w, CvType.CV_32FC4);
        coreOuter4 = new Mat(h, w, CvType.CV_32FC4);

        /* pre-compute identity & sine tables */
        baseMapX = new Mat(h, w, CvType.CV_32F);
        baseMapY = new Mat(h, w, CvType.CV_32F);
        sinX     = new Mat(h, w, CvType.CV_32F);
        sinY     = new Mat(h, w, CvType.CV_32F);
        mapX     = new Mat(h, w, CvType.CV_32F);
        mapY     = new Mat(h, w, CvType.CV_32F);

        for (int y = 0; y < h; y++)
        {
            float sy = Mathf.Sin(2f * Mathf.PI * y / distortionPeriod);
            for (int x = 0; x < w; x++)
            {
                baseMapX.put(y, x, x);
                baseMapY.put(y, x, y);

                float sx = Mathf.Sin(2f * Mathf.PI * x / distortionPeriod);
                sinX.put(y, x, sy);
                sinY.put(y, x, sx);
            }
        }
        ready = true;
    }

    /* ───────── update ───────── */
    void Update()
    {
        if (!ready || !cam.didUpdateThisFrame) return;
        Utils.webCamTextureToMat(cam, src8);

        float val = slider ? slider.value : 0f;
        if (!Mathf.Approximately(val, lastVal))
        {
            progress = Mathf.Clamp01(val);
            BuildMasksAndWarpMaps(progress);
            lastVal = val;
        }

        int k = Mathf.Clamp((int)(progress * maxKernelSize), 1, maxKernelSize);
        if ((k & 1) == 0) k++;
        Imgproc.GaussianBlur(src8, blur8, new Size(k, k), 0);

        src8.convertTo(src32,  CvType.CV_32FC4);
        blur8.convertTo(blur32, CvType.CV_32FC4);

        Imgproc.remap(src32, warped32, mapX, mapY, Imgproc.INTER_LINEAR);

        Core.multiply(warped32, blur4, dst32);
        Core.multiply(blur32,  invBlur4, tmp32);
        Core.add(dst32, tmp32, dst32);

        Core.multiply(dst32, coreOuter4, dst32);  // dark irregular spot

        dst32.convertTo(dst8, CvType.CV_8UC4);
        Utils.fastMatToTexture2D(dst8, tex);
    }

    /* ───────── Build masks + warp maps  ───────── */
    void BuildMasksAndWarpMaps(float p)
    {
        BuildBlurMask(p);
        BuildSpotMasks(p);      // now produces irregular core

        Imgproc.cvtColor(blurMask, blur4, Imgproc.COLOR_GRAY2RGBA);
        Core.subtract(ones32, blurMask, tmp32);
        Imgproc.cvtColor(tmp32, invBlur4, Imgproc.COLOR_GRAY2RGBA);

        Core.multiply(spotCoreMask, spotOuterMask, edgeMask);
        Imgproc.cvtColor(edgeMask, coreOuter4, Imgproc.COLOR_GRAY2RGBA);

        float amp = maxDistortionPixels * p;
        Core.multiply(sinX, new Scalar(amp), mapX);
        Core.multiply(sinY, new Scalar(amp), mapY);
        Core.multiply(mapX, distortionMask, mapX);
        Core.multiply(mapY, distortionMask, mapY);
        Core.add(baseMapX, mapX, mapX);
        Core.add(baseMapY, mapY, mapY);
    }

    /* ---------------- blur mask ---------------- */
    void BuildBlurMask(float p)
    {
        float baseR = Mathf.Lerp(50f, 200f, p);
        float fade = 50f, amp = 10f;

        Core.multiply(noiseMap, new Scalar(amp), irregular);
        Core.add(irregular, new Scalar(baseR), irregular);

        Core.subtract(radiusMap, irregular, blurMask);
        Core.add(blurMask, new Scalar(fade * .5f), blurMask);
        Core.divide(blurMask, new Scalar(fade), blurMask);
        Core.min(blurMask, new Scalar(1f), blurMask);
        Core.max(blurMask, new Scalar(0f), blurMask);

        int k = Mathf.Max(3, (int)(p * maxKernelSize)); if ((k & 1) == 0) k++;
        Imgproc.GaussianBlur(blurMask, blurMask, new Size(k, k), 0);
    }

    /* ---------------- irregular spot + ring ---------------- */
    void BuildSpotMasks(float p)
    {
        spotCoreMask.setTo(new Scalar(1f));
        spotOuterMask.setTo(new Scalar(1f));
        distortionMask.setTo(new Scalar(0f));

        if (p < spotStartThreshold) return;

        float t  = (p - spotStartThreshold) / (1f - spotStartThreshold);
        float e  = Mathf.Sqrt(t);
        float oR = Mathf.Lerp(10f, maxOuterRadius, e);

        float d  = 0.4f;
        float cp = Mathf.Clamp01((e - d) / (1f - d));
        float cR = Mathf.Lerp(5f, maxCoreRadius, cp);

        float fade = 50f, amp = 10f;

        /* ---------- irregular core ----------- */
        float extAmp = extensionMaxPixels * cp;               // grows with disease
        Core.multiply(noiseMap, new Scalar(extAmp), irregular); // −extAmp..+extAmp
        Core.add(irregular, new Scalar(cR), irregular);         // per-pixel radius

        Core.subtract(radiusMap, irregular, spotCoreMask);      // <0 = inside core
        Core.add(spotCoreMask, new Scalar(fade * .5f), spotCoreMask);
        Core.divide(spotCoreMask, new Scalar(fade), spotCoreMask);
        Core.min(spotCoreMask, new Scalar(1f), spotCoreMask);
        Core.max(spotCoreMask, new Scalar(0f), spotCoreMask);

        /* ---------- outer halo ------------ */
        Core.multiply(noiseMap, new Scalar(amp), tmp32);
        Core.add(tmp32, new Scalar(oR), tmp32);
        Core.subtract(radiusMap, tmp32, spotOuterMask);
        Core.add(spotOuterMask, new Scalar(fade * .5f), spotOuterMask);
        Core.divide(spotOuterMask, new Scalar(fade), spotOuterMask);
        Core.min(spotOuterMask, new Scalar(1f), spotOuterMask);
        Core.max(spotOuterMask, new Scalar(0.3f), spotOuterMask);

        /* ---------- distortion ring mask ------------ */
        float inner = cR + ringExpansion + extAmp;            // follow new outline
        float outer = inner + ringWidth;

        Core.subtract(radiusMap, new Scalar(inner), tmp32);
        Core.max(tmp32, new Scalar(0f), tmp32);
        Core.multiply(ones32, new Scalar(outer - inner), irregular);
        Core.subtract(irregular, tmp32, tmp32);
        Core.divide(tmp32, new Scalar(outer - inner), distortionMask);
        Core.min(distortionMask, new Scalar(1f), distortionMask);
        Core.max(distortionMask, new Scalar(0f), distortionMask);

        /* ---------- smooth ---------- */
        int k = Mathf.Max(3, (int)(e * maxKernelSize)); if ((k & 1) == 0) k++;
        Imgproc.GaussianBlur(spotOuterMask,  spotOuterMask,  new Size(k, k), 0);
        Imgproc.GaussianBlur(spotCoreMask,   spotCoreMask,   new Size(k, k), 0);
        Imgproc.GaussianBlur(distortionMask, distortionMask, new Size(k, k), 0);
    }

    /* ---------------- helpers ---------------- */
    Mat GenRadius(int h, int w)
    {
        Mat r = new Mat(h, w, CvType.CV_32F);
        float cx = w * .5f, cy = h * .5f;
        for (int y = 0; y < h; y++)
        {
            float dy2 = (y - cy) * (y - cy);
            for (int x = 0; x < w; x++)
                r.put(y, x, Mathf.Sqrt((x - cx) * (x - cx) + dy2));
        }
        return r;
    }
    Mat GenNoise(int h, int w, int blur = 111)
    {
        Mat n = new Mat(h, w, CvType.CV_32F);
        Core.randn(n, 0, 1);
        Imgproc.GaussianBlur(n, n, new Size(blur, blur), 0);
        Core.MinMaxLocResult mm = Core.minMaxLoc(n);
        Core.subtract(n, new Scalar(mm.minVal), n);
        Core.divide(n, new Scalar(mm.maxVal - mm.minVal), n); // 0..1
        Core.multiply(n, new Scalar(2), n);                   // 0..2
        Core.subtract(n, new Scalar(1), n);                   // −1..+1
        return n;
    }

    /* ---------------- cleanup ---------------- */
    void OnDestroy()
    {
        cam?.Stop();
        foreach (Mat m in new[]
        { src8, blur8, src32, blur32, warped32, dst32, dst8,
          blurMask, spotCoreMask, spotOuterMask, distortionMask,
          edgeMask, noiseMap, radiusMap, irregular, tmp32, ones32,
          blur4, invBlur4, coreOuter4,
          baseMapX, baseMapY, sinX, sinY, mapX, mapY })
            m?.Dispose();
    }
}
