using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class AMDEffect : MonoBehaviour
{
    [Header("AMD Settings")]
    [SerializeField] private int maxKernelSize = 51;
    [SerializeField] private float spotStartThreshold = 0.3f;

    private RawImage display;
    private Slider intensitySlider;
    private WebCamTexture cam;
    private Texture2D tex;

    private Mat matInput;
    private Mat matProcessed;
    private Mat matBlurred;
    private Mat blurMask;
    private Mat spotMask;
    private Mat noiseMap;

    private bool initialized = false;

    public void Initialize(RawImage target, Slider slider, WebCamTexture sharedCam)
    {
        display = target;
        intensitySlider = slider;
        cam = sharedCam;

        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitForWebCamInit());
    }

    IEnumerator WaitForWebCamInit()
    {
        while (cam.width <= 16)
            yield return null;

        int width = cam.width;
        int height = cam.height;

        tex = new Texture2D(width, height, TextureFormat.RGBA32, false);
        display.texture = tex;

        matInput = new Mat(height, width, CvType.CV_8UC4);
        matProcessed = new Mat(height, width, CvType.CV_8UC4);
        matBlurred = new Mat(height, width, CvType.CV_8UC4);
        blurMask = new Mat(height, width, CvType.CV_32F);
        spotMask = new Mat(height, width, CvType.CV_32F);
        noiseMap = generateStaticNoiseMap(height, width);

        initialized = true;
    }

    void Update()
    {
        if (!initialized || cam == null || !cam.didUpdateThisFrame)
            return;

        Utils.webCamTextureToMat(cam, matInput);

        float t = intensitySlider != null ? intensitySlider.value : 0f;
        float progression = Mathf.Clamp01(t);

        GenerateBlurMask(progression);
        GenerateSpotMask(progression);
        ApplyEffects(progression);

        Utils.fastMatToTexture2D(matProcessed, tex);
    }

    private void GenerateBlurMask(float progression)
    {
        int width = blurMask.cols();
        int height = blurMask.rows();
        float cx = width / 2f;
        float cy = height / 2f;

        float maxRadius = Mathf.Min(width, height) * 0.4f * progression;
        float fadeWidth = 50f;

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                float dx = x - cx;
                float dy = y - cy;
                float dist = Mathf.Sqrt(dx * dx + dy * dy);

                float maskVal = 1f;
                if (dist < maxRadius - fadeWidth / 2f)
                    maskVal = 0f;
                else if (dist < maxRadius + fadeWidth / 2f)
                    maskVal = (dist - (maxRadius - fadeWidth / 2f)) / fadeWidth;

                blurMask.put(y, x, Mathf.Clamp01(maskVal));
            }
        }

        Imgproc.GaussianBlur(blurMask, blurMask, new Size(maxKernelSize, maxKernelSize), 0);
    }

    private void GenerateSpotMask(float progression)
    {
        if (progression < spotStartThreshold)
        {
            spotMask.setTo(new Scalar(1)); // no black spot yet
            return;
        }

        float normalizedProgress = (progression - spotStartThreshold) / (1f - spotStartThreshold);

        int width = matInput.cols();
        int height = matInput.rows();
        float cx = width / 2f;
        float cy = height / 2f;

        // Calculate a circular radius for the black spot, but add more irregularity
        float radius = 200 * normalizedProgress; // The spot's radius will grow as progression increases
        float fadeWidth = 50f; // Smooth transition between the blurred area and the black spot

        // Add noise to make the spot more irregular
        float noiseScale = 0.05f; // Controls the amount of irregularity in the shape

        // Generate the circular mask with noise for more irregularity
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                float dx = x - cx;
                float dy = y - cy;
                float dist = Mathf.Sqrt(dx * dx + dy * dy);

                // Use Perlin noise to create smoother irregularity in the spot's boundary
                float perlinNoise = Mathf.PerlinNoise(x * noiseScale, y * noiseScale) * 10f; // Scale the noise for more irregularity
                float irregularRadius = radius + perlinNoise; // Add irregular noise to the radius

                float value = 1f; // Default: no effect
                if (dist < irregularRadius - fadeWidth / 2f)
                    value = 0f; // Fully blacked out
                else if (dist < irregularRadius + fadeWidth / 2f)
                    value = (dist - (irregularRadius - fadeWidth / 2f)) / fadeWidth; // Smooth fade into black

                spotMask.put(y, x, Mathf.Clamp01(value));
            }
        }

        Imgproc.GaussianBlur(spotMask, spotMask, new Size(maxKernelSize, maxKernelSize), 0);
    }




    private void ApplyEffects(float progression)
    {
        matProcessed.setTo(new Scalar(0));

        int blurKernelSize = Mathf.Clamp((int)(progression * maxKernelSize), 1, maxKernelSize);
        if (blurKernelSize % 2 == 0) blurKernelSize++;
        Imgproc.GaussianBlur(matInput, matBlurred, new Size(blurKernelSize, blurKernelSize), 0);

        int rows = matInput.rows();
        int cols = matInput.cols();

        for (int y = 0; y < rows; y++)
        {
            for (int x = 0; x < cols; x++)
            {
                double[] original = matInput.get(y, x);
                double[] blurred = matBlurred.get(y, x);

                float blurWeight = (float)blurMask.get(y, x)[0];
                float spotWeight = (float)spotMask.get(y, x)[0];

                float r = Mathf.Lerp((float)blurred[0], (float)original[0], blurWeight) * spotWeight;
                float g = Mathf.Lerp((float)blurred[1], (float)original[1], blurWeight) * spotWeight;
                float b = Mathf.Lerp((float)blurred[2], (float)original[2], blurWeight) * spotWeight;

                matProcessed.put(y, x, new double[] { r, g, b, original[3] });
            }
        }
    }

    private Mat generateStaticNoiseMap(int height, int width, int blurSize = 51)
    {
        Mat noise = new Mat(height, width, CvType.CV_32F);
        Core.randn(noise, 0.0, 1.0);
        Imgproc.GaussianBlur(noise, noise, new Size(blurSize, blurSize), 0);

        Core.MinMaxLocResult mm = Core.minMaxLoc(noise);
        Core.subtract(noise, new Scalar(mm.minVal), noise);
        Core.divide(noise, new Scalar(mm.maxVal - mm.minVal), noise);
        Core.multiply(noise, new Scalar(2.0), noise);
        Core.subtract(noise, new Scalar(1.0), noise);

        return noise;
    }

    void OnDisable() { /* cam?.Stop(); */ }

    void OnDestroy()
    {
        cam?.Stop();
        matInput?.Dispose();
        matProcessed?.Dispose();
        matBlurred?.Dispose();
        blurMask?.Dispose();
        spotMask?.Dispose();
        noiseMap?.Dispose();
    }
}
