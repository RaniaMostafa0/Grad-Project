using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class RetinitisPigmentosaEffect : MonoBehaviour
{
    /* ───────────── Inspector settings ───────────── */
    [Header("Tunnel-Vision Parameters")]
    [SerializeField, Range(3, 201)]  private int   blurSize           = 51;  // Gaussian kernel (odd)
    [SerializeField, Range(0.05f, .5f)]
    private  float rimWidthFraction   = .20f;                                // % of shorter side
    [SerializeField, Range(0f, 1f)]  private float irregularityStrength = .40f;
    [Space]
    [Tooltip("Top part of the slider that fades the last light to black")]
    [SerializeField, Range(.05f, .5f)]
    private  float fullBlindFraction  = .10f;                                // top 10 %

    /* ───────────── Runtime refs & Mats (unchanged) ───────────── */
    private RawImage      display;
    private Slider        intensitySlider;
    private WebCamTexture cam;            private Texture2D tex;

    private Mat matInput,   matProcessed; private Mat matFloat;
    private Mat tunnelMask, noiseMap, radiusMap, tmp, mask4;

    private bool  initialised;            private float lastT = -1f;
    private float maxRadius, rimWidthPx;

    /* ───────────────── entry point ───────────────── */
    public void Initialize(RawImage target, Slider slider, WebCamTexture sharedCam)
    {
        display = target; intensitySlider = slider; cam = sharedCam;
        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitForCam());
    }

    IEnumerator WaitForCam()
    {
        while (cam.width <= 16) yield return null;

        int w = cam.width, h = cam.height;
        tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
        display.texture = tex;

        matInput  = new Mat(h, w, CvType.CV_8UC4);
        matProcessed = new Mat(h, w, CvType.CV_8UC4);
        matFloat  = new Mat(h, w, CvType.CV_32FC4);

        tunnelMask = new Mat(h, w, CvType.CV_32F);
        noiseMap   = GenNoise(h, w);
        radiusMap  = GenRadius(h, w);
        tmp        = new Mat(h, w, CvType.CV_32F);
        mask4      = new Mat(h, w, CvType.CV_32FC4);

        float cx = w * .5f, cy = h * .5f;
        maxRadius  = Mathf.Sqrt(cx*cx + cy*cy);
        rimWidthPx = Mathf.Max(w, h) * rimWidthFraction;

        initialised = true;
    }

    /* ───────────────── update ───────────────── */
    void Update()
    {
        if (!initialised || !cam.didUpdateThisFrame) return;

        Utils.webCamTextureToMat(cam, matInput);

        float t = intensitySlider ? intensitySlider.value : 0f;
        if (!Mathf.Approximately(t, lastT))
        {
            BuildMask(t);
            lastT = t;
        }

        ApplyMask();
        Utils.fastMatToTexture2D(matProcessed, tex);
    }

    /* ───────────────── mask builder ───────────────── */
    void BuildMask(float t)
    {
        if (t < 1e-4f) { tunnelMask.setTo(new Scalar(1)); return; }

        /* ----- 1. warped-radius tunnel (as before) ----- */
        Core.multiply(noiseMap, new Scalar(irregularityStrength * rimWidthPx), tmp);
        Core.add(radiusMap, tmp, tmp);                          // tmp = warped radius

        float clearR  = Mathf.Lerp(maxRadius, 0f, t);
        float rimEnd  = clearR + rimWidthPx;

        Core.subtract(tmp, new Scalar(rimEnd), tunnelMask);     // radius - rimEnd
        Core.multiply(tunnelMask, new Scalar(-1f), tunnelMask);
        Core.divide  (tunnelMask, new Scalar(rimWidthPx), tunnelMask);
        Core.min(tunnelMask, new Scalar(1), tunnelMask);
        Core.max(tunnelMask, new Scalar(0), tunnelMask);

        /* ----- 2. stage-two global fade (top slider segment) ----- */
        float blindStart = 1f - fullBlindFraction;              // e.g. 0.90
        if (t > blindStart)
        {
            float k = (t - blindStart) / fullBlindFraction;     // 0→1 across final stretch
            float global = 1f - k;                              // 1→0   (linear)*
            Core.multiply(tunnelMask, new Scalar(global), tunnelMask);
        }
        /*  *swap `global = Mathf.Pow(1f - k, 2)` if you want a smoother ease-out */

        Imgproc.GaussianBlur(tunnelMask, tunnelMask, new Size(blurSize, blurSize), 0);
    }

    /* ───────────────── apply & util (unchanged) ───────────────── */
    void ApplyMask()
    {
        Imgproc.cvtColor(tunnelMask, mask4, Imgproc.COLOR_GRAY2RGBA);
        matInput.convertTo(matFloat, CvType.CV_32FC4);
        Core.multiply(matFloat, mask4, matFloat);
        matFloat.convertTo(matProcessed, CvType.CV_8UC4);
    }

    Mat GenRadius(int h, int w)
    {
        Mat r = new Mat(h, w, CvType.CV_32F);
        float cx = w*.5f, cy = h*.5f;
        for (int y=0; y<h; y++){
            float dy2 = (y-cy)*(y-cy);
            for(int x=0;x<w;x++){
                float dx2 = (x-cx)*(x-cx);
                r.put(y,x, Mathf.Sqrt(dx2+dy2));
            }}
        return r;
    }
    Mat GenNoise(int h,int w)
    {
        Mat n=new Mat(h,w,CvType.CV_32F);
        Core.randn(n,0,1);
        Imgproc.GaussianBlur(n,n,new Size(blurSize,blurSize),0);
        Core.MinMaxLocResult mm=Core.minMaxLoc(n);
        Core.subtract(n,new Scalar(mm.minVal),n);
        Core.divide(n,new Scalar(mm.maxVal-mm.minVal),n);
        Core.multiply(n,new Scalar(2),n);
        Core.subtract(n,new Scalar(1),n);
        return n;
    }
    void OnDestroy()
    {
        cam?.Stop();
        matInput?.Dispose(); matProcessed?.Dispose(); matFloat?.Dispose();
        tunnelMask?.Dispose(); noiseMap?.Dispose(); radiusMap?.Dispose();
        tmp?.Dispose(); mask4?.Dispose();
    }
}
