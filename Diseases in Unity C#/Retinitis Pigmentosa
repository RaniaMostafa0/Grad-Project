using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class RetinitisPigmentosaEffect : MonoBehaviour
{
    /* ───────────── Inspector settings ───────────── */
    [Header("Tunnel-Vision Parameters")]
    [SerializeField, Range(3, 201)] private int   blurSize         = 51;   // Gaussian kernel (odd)
    [SerializeField, Range(0.05f, 0.5f)]
    private  float rimWidthFraction   = 0.20f;                             // % of shorter side
    [SerializeField, Range(0f, 1f)]
    private  float irregularityStrength = 0.40f;                           // 0 = perfect circle

    /* ───────────── Runtime references ───────────── */
    private RawImage      display;
    private Slider        intensitySlider;
    private WebCamTexture cam;
    private Texture2D     tex;

    /* ───────────── OpenCV mats ───────────── */
    private Mat matInput, matProcessed;   // 8UC4
    private Mat matFloat;                 // 32FC4
    private Mat tunnelMask;               // 32F
    private Mat noiseMap;                 // 32F   (-1 … 1)
    private Mat radiusMap;                // 32F
    private Mat tmp;                      // 32F   helper / warped radius
    private Mat mask4;                    // 32FC4

    /* ───────────── Geometry constants ───────────── */
    private bool  initialized;
    private float lastSlider  = -1f;
    private float maxRadius;              // centre → far corner
    private float rimWidthPx;             // fade-rim width

    /* ─────────────────── Public entry point ─────────────────── */
    public void Initialize(RawImage target, Slider slider, WebCamTexture sharedCam)
    {
        display        = target;
        intensitySlider = slider;
        cam             = sharedCam;

        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitForWebCamInit());
    }

    IEnumerator WaitForWebCamInit()
    {
        while (cam.width <= 16) yield return null;      // wait for webcam

        int w = cam.width;
        int h = cam.height;

        tex            = new Texture2D(w, h, TextureFormat.RGBA32, false);
        display.texture = tex;

        matInput     = new Mat(h, w, CvType.CV_8UC4);
        matProcessed = new Mat(h, w, CvType.CV_8UC4);
        matFloat     = new Mat(h, w, CvType.CV_32FC4);

        tunnelMask = new Mat(h, w, CvType.CV_32F);
        noiseMap   = GenerateNoiseMap(h, w);
        radiusMap  = CreateRadiusMap(h, w);
        tmp        = new Mat(h, w, CvType.CV_32F);
        mask4      = new Mat(h, w, CvType.CV_32FC4);

        float cx = w * 0.5f, cy = h * 0.5f;
        maxRadius  = Mathf.Sqrt(cx * cx + cy * cy);
        rimWidthPx = Mathf.Max(w, h) * rimWidthFraction;

        initialized = true;
    }

    /* ─────────────────── Update ─────────────────── */
    void Update()
    {
        if (!initialized || !cam.didUpdateThisFrame) return;

        Utils.webCamTextureToMat(cam, matInput);

        float t = intensitySlider ? intensitySlider.value : 0f;   // 0 … 1
        if (!Mathf.Approximately(t, lastSlider))
        {
            BuildTunnelMask(t);
            lastSlider = t;
        }

        ApplyTunnelEffect();
        Utils.fastMatToTexture2D(matProcessed, tex);
    }

    /* ─────────────────── Mask building ─────────────────── */
    private void BuildTunnelMask(float t)
    {
        if (t <= 0.0001f)          // slider at zero → clear view
        {
            tunnelMask.setTo(new Scalar(1f));
            return;
        }

        /* ----- create warped radius map (bumpy outline) ----- */
        // tmp = radiusMap  +  noise * (irregularityStrength * rimWidthPx)
        Core.multiply(noiseMap, new Scalar(irregularityStrength * rimWidthPx), tmp);
        Core.add(radiusMap, tmp, tmp);                       // tmp == warpedRadius

        /* ----- compute fade based on warped radius ----- */
        float clearRadius = Mathf.Lerp(maxRadius, 0f, t);    // shrinks with t
        float rimEnd      = clearRadius + rimWidthPx;

        // tmp = (rimEnd − warpedRadius) / rimWidthPx
        Core.subtract(tmp, new Scalar(rimEnd), tunnelMask);  // tunnelMask = warpedRadius − rimEnd
        Core.multiply(tunnelMask, new Scalar(-1.0f), tunnelMask);
        Core.divide(tunnelMask, new Scalar(rimWidthPx), tunnelMask);

        // clamp 0…1
        Core.min(tunnelMask, new Scalar(1f), tunnelMask);
        Core.max(tunnelMask, new Scalar(0f), tunnelMask);

        /* ----- blur for softness ----- */
        Imgproc.GaussianBlur(tunnelMask, tunnelMask, new Size(blurSize, blurSize), 0);
    }

    /* ─────────────────── Effect application ─────────────────── */
    private void ApplyTunnelEffect()
    {
        Imgproc.cvtColor(tunnelMask, mask4, Imgproc.COLOR_GRAY2RGBA);

        matInput.convertTo(matFloat, CvType.CV_32FC4);
        Core.multiply(matFloat, mask4, matFloat);
        matFloat.convertTo(matProcessed, CvType.CV_8UC4);
    }

    /* ─────────────────── Helpers ─────────────────── */
    private Mat CreateRadiusMap(int h, int w)
    {
        Mat r = new Mat(h, w, CvType.CV_32F);
        float cx = w * 0.5f, cy = h * 0.5f;

        for (int y = 0; y < h; y++)
        {
            float dy2 = (y - cy) * (y - cy);
            for (int x = 0; x < w; x++)
            {
                float dx2 = (x - cx) * (x - cx);
                r.put(y, x, Mathf.Sqrt(dx2 + dy2));
            }
        }
        return r;
    }

    private Mat GenerateNoiseMap(int h, int w)
    {
        Mat n = new Mat(h, w, CvType.CV_32F);
        Core.randn(n, 0.0, 1.0);                          // white noise
        Imgproc.GaussianBlur(n, n, new Size(blurSize, blurSize), 0);

        // normalise to [-1 … 1]
        Core.MinMaxLocResult mm = Core.minMaxLoc(n);
        Core.subtract(n, new Scalar(mm.minVal), n);
        Core.divide(n,  new Scalar(mm.maxVal - mm.minVal), n);
        Core.multiply(n, new Scalar(2.0), n);
        Core.subtract(n, new Scalar(1.0), n);
        return n;
    }

    /* ─────────────────── Cleanup ─────────────────── */
    void OnDestroy()
    {
        cam?.Stop();
        matInput?.Dispose();  matProcessed?.Dispose();  matFloat?.Dispose();
        tunnelMask?.Dispose(); noiseMap?.Dispose();     radiusMap?.Dispose();
        tmp?.Dispose();        mask4?.Dispose();
    }
}
