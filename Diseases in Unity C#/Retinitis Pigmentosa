using UnityEngine;
using UnityEngine.UI;
using OpenCVForUnity.CoreModule;
using OpenCVForUnity.ImgprocModule;
using OpenCVForUnity.UnityUtils;
using System.Collections;

[RequireComponent(typeof(RawImage))]
public class RetinitisPigmentosaEffect : MonoBehaviour
{
    /* ───────────── Inspector settings ───────────── */
    [Header("Tunnel-Vision Parameters")]
    [SerializeField] private int blurSize = 51;   // Max blur kernel size
    [SerializeField] private float tunnelStrength = 1.0f;
    [SerializeField] private float nightBlindnessThreshold = 60f;
    [SerializeField] private float nightBlindnessFactor = 0.4f;
    [SerializeField] private float maxBlurAmount = 3f;

    /* ───────────── Runtime references ───────────── */
    private RawImage display;
    private Slider intensitySlider;
    private WebCamTexture cam;
    private Texture2D tex;

    /* ───────────── OpenCV mats ───────────── */
    private Mat matInput, matProcessed;  // 8UC4
    private Mat matFloat;                // 32FC4
    private Mat tunnelMask;              // 32F
    private Mat noiseMap;
    private Mat radiusMap;
    private Mat irregular;
    private Mat mask4;

    private bool initialized = false;
    private float lastSliderValue = -1f;

    /* ─────────────────────────────────────────────── */

    public void Initialize(RawImage target, Slider slider, WebCamTexture sharedCam)
    {
        display = target;
        intensitySlider = slider;
        cam = sharedCam;

        if (!cam.isPlaying) cam.Play();
        StartCoroutine(WaitForWebCamInit());
    }

    IEnumerator WaitForWebCamInit()
    {
        while (cam.width <= 16) yield return null;

        int w = cam.width;
        int h = cam.height;

        tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
        display.texture = tex;

        matInput = new Mat(h, w, CvType.CV_8UC4);
        matProcessed = new Mat(h, w, CvType.CV_8UC4);
        matFloat = new Mat(h, w, CvType.CV_32FC4);

        tunnelMask = new Mat(h, w, CvType.CV_32F);
        noiseMap = GenerateNoiseMap(h, w);
        radiusMap = CreateRadiusMap(h, w);
        irregular = new Mat(h, w, CvType.CV_32F);
        mask4 = new Mat(h, w, CvType.CV_32FC4);

        initialized = true;
    }

    /* ───────────────────────── Update ───────────────────────── */
    void Update()
    {
        if (!initialized || !cam.didUpdateThisFrame) return;

        Utils.webCamTextureToMat(cam, matInput);

        float t = intensitySlider ? intensitySlider.value : 0f;
        float progression = Mathf.Clamp01(t * t);

        if (!Mathf.Approximately(progression, lastSliderValue))
        {
            GenerateIrregularTunnelMask(progression);
            lastSliderValue = progression;
        }

        ApplyCombinedEffect(progression);

        Utils.fastMatToTexture2D(matProcessed, tex);
    }

    /* ───────────────────────── Mask building ───────────────────────── */
    private Mat CreateRadiusMap(int h, int w)
    {
        Mat r = new Mat(h, w, CvType.CV_32F);
        float cx = w * 0.5f, cy = h * 0.5f;

        for (int y = 0; y < h; y++)
        {
            float dy2 = (y - cy) * (y - cy);
            for (int x = 0; x < w; x++)
            {
                float dx2 = (x - cx) * (x - cx);
                r.put(y, x, Mathf.Sqrt(dx2 + dy2));
            }
        }
        return r;
    }

    private void GenerateIrregularTunnelMask(float p)
    {
        if (p <= 0f)
        {
            tunnelMask.setTo(new Scalar(1f));
            return;
        }

        float baseRadius = Mathf.Lerp(Mathf.Min(matInput.cols(), matInput.rows()) * 0.5f, 0f, p);

        Core.multiply(noiseMap, new Scalar(0.4f), irregular);  // 0.4 * noise
        Core.add(irregular, Scalar.all(1.0), irregular);       // 1 + ...
        Core.multiply(irregular, new Scalar(baseRadius), irregular);

        Core.subtract(irregular, radiusMap, tunnelMask);
        Core.divide(tunnelMask, new Scalar(80f), tunnelMask);
        Core.min(tunnelMask, new Scalar(1f), tunnelMask);
        Core.max(tunnelMask, new Scalar(0f), tunnelMask);

        Imgproc.GaussianBlur(tunnelMask, tunnelMask, new Size(blurSize, blurSize), 0);
    }

    /* ───────────────────────── Combined effect ───────────────────────── */
    private void ApplyCombinedEffect(float progression)
    {
        matInput.convertTo(matFloat, CvType.CV_32FC4);

        // Expand tunnel mask to 4 channels
        Imgproc.cvtColor(tunnelMask, mask4, Imgproc.COLOR_GRAY2RGBA);

        // Multiply image by mask
        Core.multiply(matFloat, mask4, matFloat);

        // Handle night blindness (dim + blur)
        float averageBrightness = GetAverageBrightness(matInput);
        float nightMultiplier = 1f;
        float blurIntensity = 0f;

        if (averageBrightness < nightBlindnessThreshold)
        {
            float darkRatio = Mathf.InverseLerp(nightBlindnessThreshold, 0f, averageBrightness);
            float adjustedProgression = Mathf.Pow(progression, 1.5f);
            float adjustedDarkRatio = Mathf.Pow(darkRatio, 1.5f);

            nightMultiplier = Mathf.Lerp(nightBlindnessFactor, 1f, adjustedDarkRatio);
            blurIntensity = Mathf.Lerp(0f, maxBlurAmount, adjustedDarkRatio * adjustedProgression);
        }

        // Apply night dimming
        Core.multiply(matFloat, new Scalar(nightMultiplier, nightMultiplier, nightMultiplier, 1f), matFloat);

        // Convert back to 8-bit
        matFloat.convertTo(matProcessed, CvType.CV_8UC4);

        // Apply additional blur if necessary
        if (blurIntensity > 0.01f)
        {
            int ksize = Mathf.RoundToInt(blurSize * blurIntensity);
            ksize = Mathf.Clamp(ksize | 1, 3, 51); // must be odd
            Imgproc.GaussianBlur(matProcessed, matProcessed, new Size(ksize, ksize), 0);
        }
    }

    /* ───────────────────────── Utilities ───────────────────────── */
    private float GetAverageBrightness(Mat mat)
    {
        Mat gray = new Mat();
        Imgproc.cvtColor(mat, gray, Imgproc.COLOR_RGBA2GRAY);
        Scalar meanScalar = Core.mean(gray);
        gray.Dispose();
        return (float)meanScalar.val[0];
    }

    private Mat GenerateNoiseMap(int h, int w)
    {
        Mat n = new Mat(h, w, CvType.CV_32F);
        Core.randn(n, 0.0, 1.0);
        Imgproc.GaussianBlur(n, n, new Size(blurSize, blurSize), 0);

        Core.MinMaxLocResult mm = Core.minMaxLoc(n);
        Core.subtract(n, new Scalar(mm.minVal), n);
        Core.divide(n, new Scalar(mm.maxVal - mm.minVal), n);
        Core.multiply(n, new Scalar(2.0), n);
        Core.subtract(n, new Scalar(1.0), n);
        return n;
    }

    /* ───────────────────────── Cleanup ───────────────────────── */
    void OnDestroy()
    {
        cam?.Stop();
        matInput?.Dispose();
        matProcessed?.Dispose();
        matFloat?.Dispose();
        tunnelMask?.Dispose();
        noiseMap?.Dispose();
        radiusMap?.Dispose();
        irregular?.Dispose();
        mask4?.Dispose();
    }
}
